Generate OnPaint Explained


MouseMessage.h

This is where the window class is defined for the application. It derives a new class called CMouseMessage from the CFrameWnd class. All new classes must be derived from a base class of the MFC classes. Here it declares the constructor CMouseMessage . It then proceeds to setup the messages handlers. These are the afx_msg functions. This program will deal only with OnPaint , OnLButtonDown and OnRButtonDown messages. The #ifndef, #define and #endif are all used here to make sure that the header file does not get included more than once in the project, even though it is included in more than one file. The rule of thumb here is to always use the preprocessor statements in the header file and then include each header file in each other file that you require the code that is written in the header file. Example would be the MouseApp.cpp. This will be explained when the MouseApp.cpp file is being explained.

MouseMessage.cpp

First notice that there is a character array declared and given an initial value. This is the value that will be displayed when the application first starts. This is done by the On_Paint message handler. Then there are two variables of integer type that are declared. They are given the initial value of 1 and 1. This is used by the TextOut function when using the device context in On_Paint. This means that when the X and Y variables have the value of 1 and 1 , the string that is stored in the str variable will be displayed at location 1,1 in the window. The reason that this program is using the variables X and Y is that when the mouse button is pressed down , we want the message of which mouse button was pressed to be displayed at the location of where the button was pressed. Instead of always at the top. If you wish to try this out , you can change the TextOut(…) function. Remove the variable names and place the 1 and 1 values and see what happens. You will notice that the message is always displayed at the top left portion of the screen. 

The constructor basically just creates a simple window, with the title of Mouse Messages. Again you can play with this, as we did in Chapter two to create the window of your own size and characteristics. But in this case I decided to make the window a basic window. Go ahead and play. (Look up the Create function of CWnd class). The OnPaint function declares a variable of CPaintDC, which is the device context for OnPaint messages. CClientDC is used elsewhere but in OnPaint you must use CPaintDC. Once this device context is declared now your application can paint the screen when required. Then the wsprintf ( ) function is used to format the string of characters that are stored in str. Then the dc.TextOut(…) function will display what is stored in the string str at the location determined by the value of X and Y. Now you see the value of declaring the variables X and Y before.

OnLButtonDown function then will be processed when the left mouse button is pressed. What happens here is the function accepts the two variables Flags and loc. Flags check to see if the shift or control key was pressed and loc is a structure of CPoint which really just holds the X and Y co-ordinates of where on the screen the mouse button was pressed. So loc.x is assigned to the variable that is being used in the TextOut(…) function. The same is true for the Y value stored in loc.y. 

Now the application knows, at what location of the screen the mouse button was pressed. It then proceeds to format str with the new value of "The left mouse button was pressed down". Therefore when OnPaint repaints the screen the location of where the text gets displayed and what gets displayed has changed to the new values. The message is displayed where the mouse was clicked. The call InvalidateRect(Null) calls the OnPaint function and tells it to repaint the screen. When the screen gets repainted, it is done so with the new values for X, Y and str. Remember InvalidateRect takes two arguments. One to determine which portion of the screen needs to be repainted ( in this case the value is NULL so the whole window is repainted) and the value of TRUE or FALSE to re-writing the background. Since this argument is a default value of TRUE, the background is automatically repainted. If you entered the value of FALSE the background would not be repainted and the original message that was displayed at the beginning ("This is what will be displayed when the window starts") would always be displayed. Try it. 

The OnRButtonDown function works the same as the OnLButtonDown function. The only thing that changes is the str value. This message is passed whenever the right mouse button is pressed. It will also keep track of where the mouse was at the time the button was pressed and will reset the value of X,Y and str variables to display the proper message at the proper place.

MouseApp.h

This is where the application class is defined. Notice that it is derived from the CWinApp class. Again I can not stress enough : usually all new classes are derived from a base class that is in MFC. This just makes code generation quicker because you can use the methods and variables already declared in these functions. It then proceeds to declare the constructor and the InitInstance functions.

MouseApp.cpp

This defines the constructor for this class. You will notice that there is only a semicolon in this definition. At this time our program does not require it , but there will be times in this course where it will be required. So I just wanted to make you are aware that if you did not explicitly declare a constructor the compiler will do so for you. Then it defines InitIstance( ). This will be called to create the window for your application. Since most of the code is written in the window portion of the application it would be nice to use it. First it uses the pointer variable m_pMainWnd , which is declared inside of CWinApp. It dynamically creates memory the size of your window class CMouseMessage. It then returns a address of where in memory this memory was reserved. Then it calls the built in method ShowWindow, from CWnd, which takes the parameter m_nCmdShow. To display the window and then it calls the UpdateWindow function to update the screen. This really calls the OnPaint message. Remember if you did not have an OnPaint method, the compiler would have used the default one already declared in the CWnd class. In the case of most applications, this method, which is virtual, is almost always re-written. Then is returns TRUE to indicate the window was created successfully.

MainFile.cpp

Here the afxwin.h, MouseMessage.h and the MouseApp.h header files were included. The difference between afxwin and the other header files is the syntax of how to include them. The < > signs are used when the header file is a precompiled header file and is already known to the compiler. The double quotes are used to indicate that the header file is not a standard header file. It is a user defined header file. In other words, the programmer wrote the header file at design time. Notice that all .cpp files have the afxwin.h header file. This is standard unless you are using the Graphical Environment. This file, then includes the MouseApp and the MouseMessage header files. Remember the rule of thumb , if the file is going to use a portion of a header file it must be included into that file. In this case MouseApp is required because we are declaring a variable of the class CMouseApp, which is defined inside the MouseApp.h, so it has to be included. The MouseMessage header file must be included because the BEGIN_MESSAGE_MAP macro requires that we identify which window the message map is be declared for. In this case CMouseMessage. Then this file includes the message macros for each of the message that this program will deal with ( ON_WM_PAINT, ON_WM_LBUTTONDOWN and ON_WM_RBUTTONDOWN) . This file also then declares an object of the CMouseApp class and this is what makes the application become real.


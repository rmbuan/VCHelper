{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f28\fswiss\fcharset0\fprq2{\*\panose 020b0604030504040204}Verdana;}
{\f31\froman\fcharset238\fprq2 Times New Roman CE;}{\f32\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f34\froman\fcharset161\fprq2 Times New Roman Greek;}{\f35\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f36\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f37\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f38\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f255\fswiss\fcharset238\fprq2 Verdana CE;}
{\f256\fswiss\fcharset204\fprq2 Verdana Cyr;}{\f258\fswiss\fcharset161\fprq2 Verdana Greek;}{\f259\fswiss\fcharset162\fprq2 Verdana Tur;}{\f262\fswiss\fcharset186\fprq2 Verdana Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;
\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;
\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green51\blue102;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}
{\s1\ql \li0\ri0\keepn\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs32\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 1;}{
\s2\ql \li0\ri0\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\fs24\cf9\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 2;}{\*\cs10 \additive Default Paragraph Font;}{
\s15\ql \fi720\li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\cf9\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext15 Body Text 2;}}{\info{\title Introduction to Basic Program}{\author Information Technology}
{\operator buan}{\creatim\yr2000\mo8\dy10\hr13\min50}{\revtim\yr2000\mo8\dy10\hr13\min50}{\version2}{\edmins0}{\nofpages2}{\nofwords310}{\nofchars1768}{\*\company George Brown College}{\nofcharsws2171}{\vern8247}}
\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\formshade\horzdoc\dgmargin\dghspace180\dgvspace180\dghorigin1800\dgvorigin1440\dghshow1\dgvshow1
\jexpand\viewkind1\viewscale100\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule \fet0\sectd \linex0\endnhere\sectlinegrid360\sectdefaultcl {\*\pnseclvl1
\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5
\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s1\ql \li0\ri0\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 
\b\fs32\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f28\cf17 Generate an OnPaint Message
\par }\pard\plain \s2\ql \li0\ri0\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\fs24\cf9\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b0 
\par There are times when you wish to have your application redrawn because the window is invalid. This means that it is not displaying what is required. Either because the window for your application was covered up by another window and is now uncovered, or y
our application now needs to show another part of your application.
\par 
\par To accomplish }{\b0 this,}{\b0  use the InvalidateRect( ) function. It is important to mention here that this function, will not update the window immediately. Redrawing the window is a time consumin
g task, for the CPU, therefore InvalidateRect will tell Windows that the window needs to be redrawn, it is Windows (OS) that will decide when the window will actually be redrawn. 
\par 
\par InvalidateRect( ) is a function defined inside of the class CWnd. The proto
type of this function is void CWnd::InvalidateRect(LPCRECT lpRegion, BOOL Erase = TRUE). First you will notice that LPCRECT data type is a long pointer to the variable lpRegion. Which is an area of the screen that must be redrawn. As mentioned before, red
r
awing the window is a time consuming task so only the portion that needs to be redrawn should redrawn. This saves time and makes your application perform better. lpRegion is an object of the class CRect. CRect as you might have guessed by now, contains a 
s
tructure of the type Rect. Just to refresh your memory, Rect is a structure that has four variables. Top, Left, Bottom, Right. These co-ordinates have the area of the window that needs to be redrawn. If you wish you can have the entire window redrawn by s
p
ecifying this value to be NULL. Notice that the second parameter is defaulted to True. This parameter has to do with whether or not the background will also be redrawn. So in effect InvalidateRect will generate an WM_PAINT message or call the message hand
ler OnPaint, however you would like to think about it.
\par 
\par Now back to the LButtonDown and RButtonDown messages.
\par 
\par Here are the things that have to happen to process messages from the mouse buttons.
\par 
\par Create a window to hold your application. 
\par Create an application message. 
\par Declare the message map. 
\par Write the message handler. The message handle must explain, what to do when the left or right button is pressed. This will be to display a message of which button is pressed at the location of where the mouse was at the time. 
\par 
\par Each time the mouse button is pressed, if the programmer does not clear the screen ( or generate a WM_PAINT message) the window will just keep displaying the message of which button was pressed and the next time the mouse button is pressed the 
old message will still be displayed on the screen. 
\par 
\par What you want to accomplish, with this exercise, is to create a single message to be displayed on the screen at any given time.
\par 
\par }{
\par }}